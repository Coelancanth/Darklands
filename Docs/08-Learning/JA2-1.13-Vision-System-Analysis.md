# JA2 1.13 Vision System Analysis

**Date**: 2025-09-11  
**Analyzed By**: Tech Lead  
**Source**: JA2 1.13 Community Mod (C++ codebase)

## Executive Summary

JA2 1.13 implements one of the most sophisticated vision systems in tactical gaming, handling complex scenarios including day/night cycles, directional facing, environmental effects, camouflage, interrupts, and asymmetric vision. This analysis examines their implementation to extract patterns applicable to Darklands.

## Core Architecture

### 1. Fixed-Point Math for Precision

```cpp
// From LOS.h
typedef INT64 FIXEDPT;  // 64-bit for large maps
#define FIXEDPT_WHOLE_BITS 11
#define FIXEDPT_FRACTIONAL_BITS 20
#define FIXEDPT_FRACTIONAL_RESOLUTION 1048576
```

**Key Insight**: JA2 uses fixed-point math throughout for deterministic calculations. No floating-point in core gameplay logic - critical for multiplayer sync and save/replay systems.

### 2. Multi-Layered Vision System

The vision system consists of several interacting layers:

1. **Line of Sight (LOS)** - Physical ray-casting with obstruction
2. **Distance Visible** - Environmental and personal modifiers
3. **Opponent List (OppList)** - Tracking who sees whom
4. **Interrupt System** - Reaction to new sightings

### 3. Opponent List (OppList) System

```cpp
// From opplist.h
extern INT8 gbPublicOpplist[MAXTEAMS][TOTAL_SOLDIERS];
extern INT8 gbSeenOpponents[TOTAL_SOLDIERS][TOTAL_SOLDIERS];
extern INT32 gsLastKnownOppLoc[TOTAL_SOLDIERS][TOTAL_SOLDIERS];
```

The OppList tracks visibility states:
- `SEEN_CURRENTLY` - Can see right now
- `SEEN_THIS_TURN` - Saw earlier this turn
- `HEARD_LAST_TURN` - Heard but not seen
- `NOT_HEARD_OR_SEEN` - No awareness

**Performance Optimization**: Public team lists avoid N×N checks for every soldier.

## Vision Calculation Pipeline

### 1. Distance Visible Calculation

```cpp
INT16 DistanceVisible(SOLDIERTYPE *pSoldier, INT8 bFacingDir, INT8 bSubjectDir, 
                      INT32 sSubjectGridNo, INT8 bLevel, 
                      const BOOLEAN& isCowering, const UINT8& tunnelVision)
{
    // Base visibility from soldier stats
    sDistVisible = MaxNormalDistanceVisible();
    
    // Apply personal modifiers (fatigue, wounds, etc.)
    // Apply equipment modifiers (binoculars, scopes)
    // Apply environmental effects (light, weather, smoke)
    sDistVisible = AdjustMaxSightRangeForEnvEffects(pSoldier, bLightLevel, sDistVisible);
    
    // Apply directional modifiers (tunnel vision, peripheral vision)
    // Apply stance modifiers (prone sees less far)
    
    return sDistVisible;
}
```

### 2. Environmental Effect Adjustments

```cpp
INT16 AdjustMaxSightRangeForEnvEffects(SOLDIERTYPE *pSoldier, INT8 bLightLevel, INT16 sDistVisible)
{
    // Complex light level calculations
    // Day/night cycle effects
    // Weather effects (rain, sandstorm)
    // Smoke and gas clouds
    // Muzzle flash temporary visibility boost
}
```

### 3. Line of Sight Testing

```cpp
INT32 SoldierToSoldierLineOfSightTest(SOLDIERTYPE *pStartSoldier, SOLDIERTYPE *pEndSoldier, 
                                       INT8 bAware, int iTileSightLimit, 
                                       UINT8 ubAimLocation, bool adjustForSight, bool cthCalc)
{
    // First check distance visibility
    iTileSightLimit = pStartSoldier->GetMaxDistanceVisible(pEndSoldier->sGridNo, 
                                                           pEndSoldier->pathing.bLevel, 
                                                           iTileSightLimit);
    
    // Then perform ray-cast for obstructions
    // Check for windows, walls, trees
    // Account for stance heights (standing, crouched, prone)
    // Handle multi-level buildings
}
```

## Advanced Features

### 1. Asymmetric Vision Ranges

Different unit types have different base vision ranges:
- Soldiers: Variable based on stats
- Bloodcats: Different vision in different conditions
- Civilians: Generally lower vision

### 2. Directional Facing & Tunnel Vision

```cpp
// Tunnel vision reduces peripheral awareness
// Facing direction affects what you can see
if (SoldierHasLimitedVision(pSoldier)) {
    return DistanceVisible(this, this->pathing.bDesiredDirection, ...);
}
```

### 3. Interrupt System Integration

```cpp
void ManSeesMan(SOLDIERTYPE *pSoldier, SOLDIERTYPE *pOpponent, ...)
{
    // New sighting triggers interrupt checks
    if (fNewOpponent) {
        pSoldier->bNewOppCnt++;
        
        if (StandardInterruptConditionsMet(pSoldier, pOpponent->ubID, bOldOppList)) {
            ReevaluateBestSightingPosition(pSoldier, 
                CalcInterruptDuelPts(pSoldier, pOpponent->ubID, TRUE));
        }
    }
}
```

### 4. Noise System Integration

```cpp
enum NoiseTypes {
    NOISE_MOVEMENT,
    NOISE_GUNFIRE,
    NOISE_EXPLOSION,
    NOISE_SCREAM,
    NOISE_DOOR_SMASHING,
    NOISE_SILENT_ALARM, // only heard by enemies
    NOISE_VOICE, // for enemy taunts
};

void MakeNoise(UINT8 ubNoiseMaker, INT32 sGridNo, INT8 bLevel, 
               UINT8 ubTerrType, UINT8 ubVolume, UINT8 ubNoiseType);
```

### 5. Wake/Alert States (Implicit)

While not explicitly using "wake states" like we designed, JA2 has:
- **Alert Status**: Green/Yellow/Red states
- **Opponent Count**: Triggers combat mode when opponents seen
- **Neutral States**: Non-hostile until triggered

```cpp
// Bloodcat wake-up example
if (pSoldier->ubBodyType == BLOODCAT && pSoldier->aiData.bNeutral) {
    if (pSoldier->aiData.bOppCnt == 0) {
        PlayJA2Sample(BLOODCAT_ROAR, ...); // Wake up roar
    }
    MakeBloodcatsHostile();
}
```

## Performance Optimizations

### 1. Public Opponent Lists
```cpp
// Team-wide visibility to avoid N×N checks
gbPublicOpplist[MAXTEAMS][TOTAL_SOLDIERS];
```

### 2. Caching and Dirty Flags
- Vision only recalculated when positions change
- Team visibility shared to reduce calculations
- Sight limits cached per turn

### 3. Tiered Distance Checks
```cpp
// Quick distance reject before expensive LOS
if (PythSpacesAway(sGridNo1, sGridNo2) > MAX_SIGHT_RANGE) {
    return FALSE; // Don't bother with expensive checks
}
```

### 4. Fixed-Point Math
All calculations use integer/fixed-point math for speed and determinism.

## Key Architectural Decisions

### 1. Separation of Concerns
- **LOS.cpp**: Physical line-of-sight and ballistics
- **opplist.cpp**: Who sees whom, memory of sightings
- **Interface**: Visual representation and player feedback

### 2. Deterministic Design
- No floating-point in core logic
- Fixed random seeds for visibility checks
- Reproducible calculations for save/load

### 3. Performance-Conscious
- Team lists prevent O(n²) explosion
- Distance checks before expensive ray-casts
- Smart caching of visibility data

### 4. Rich Feature Set
- Day/night cycles
- Weather effects
- Smoke/gas clouds
- Camouflage
- Directional awareness
- Peripheral vision
- Muzzle flash visibility
- Sound propagation

## Lessons for Darklands

### What to Adopt

1. **Fixed-Point Math**: Essential for determinism
2. **Team Opponent Lists**: Prevents O(n²) performance issues
3. **Tiered Distance Checks**: Cheap rejections before expensive calculations
4. **Separation of Physical/Logical**: LOS vs awareness tracking
5. **State Tracking**: Remember last known positions
6. **Interrupt Integration**: Vision changes trigger gameplay events

### What to Simplify

1. **Environmental Effects**: Start without day/night, weather
2. **Directional Facing**: Can add later if needed
3. **Complex Height System**: Our 2D system is simpler
4. **Camouflage System**: Not needed initially

### What to Improve

1. **Explicit Wake States**: Our design is cleaner than JA2's implicit system
2. **Shadowcasting FOV**: JA2 uses ray-casting, we'll use proper FOV
3. **Cleaner Architecture**: Modern C# allows better separation
4. **Async Performance**: Can parallelize FOV calculations

## Implementation Recommendations

### Phase 1: Core Vision System
```csharp
public class VisionSystem {
    // Team opponent lists (from JA2)
    Dictionary<Team, HashSet<ActorId>> teamVisibility;
    
    // Individual tracking (from JA2)
    Dictionary<(ActorId, ActorId), SightingInfo> sightings;
    
    // Our improvement: explicit wake states
    Dictionary<ActorId, ActivationState> wakeStates;
}
```

### Phase 2: Performance Optimizations
```csharp
public bool CanSee(Actor viewer, Actor target) {
    // Tier 1: Wake state check (our improvement)
    if (viewer.State == ActivationState.Dormant) return false;
    
    // Tier 2: Distance check (from JA2)
    if (Distance(viewer, target) > viewer.VisionRange) return false;
    
    // Tier 3: FOV check (our improvement over JA2's LOS)
    return CalculateFOV(viewer).Contains(target.Position);
}
```

### Phase 3: Advanced Features
- Noise propagation (from JA2)
- Interrupt system (from JA2)
- Last known positions (from JA2)
- Alert chains (our improvement)

## Critical Success Factors

1. **Determinism First**: Every calculation must be reproducible
2. **Performance Scaling**: Must handle 50+ actors smoothly
3. **Save Compatibility**: Vision state must serialize cleanly
4. **Clear State Transitions**: Wake/alert states must be unambiguous
5. **Player Feedback**: Clear indication of who sees whom

## Conclusion

JA2 1.13's vision system is a masterclass in tactical game design, balancing realism, performance, and gameplay. Their core architecture - separating physical LOS from logical awareness tracking - is sound and should be adopted. Our improvements (explicit wake states, shadowcasting FOV) will modernize the approach while maintaining the tactical depth that makes JA2's combat so compelling.

The key lesson: **Start simple, layer complexity gradually, always maintain determinism.**