name: Scheduled Maintenance

on:
  schedule:
    # Run every Monday at 3 AM UTC
    - cron: '0 3 * * 1'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  auto-maintenance:
    name: ğŸ§¹ Automated Maintenance
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
        
    - name: ğŸ§¹ Clean up stale artifacts
      run: |
        echo "ğŸ§¹ Cleaning stale build artifacts..."
        find . -type d -name "bin" -o -name "obj" | xargs rm -rf || true
        find . -name "*.orig" -delete || true
        find . -name "*~" -delete || true
        
    - name: ğŸ”§ Auto-format entire codebase
      run: |
        echo "ğŸ”§ Formatting all C# files..."
        dotnet format src/Darklands.Core.csproj --verbosity diagnostic || true
        dotnet format tests/Darklands.Core.Tests.csproj --verbosity diagnostic || true
        dotnet format Darklands.csproj --verbosity diagnostic || true
        
    - name: ğŸ”§ Update tool manifest
      run: |
        echo "ğŸ”§ Ensuring tools are up to date..."
        dotnet tool restore || {
          echo "âš ï¸ Tool restore failed, attempting fresh install..."
          dotnet tool install --global husky --version 0.7.1 || true
        }
        
    - name: ğŸ“Š Generate code metrics
      run: |
        echo "ğŸ“Š Analyzing code metrics..."
        
        # Count lines of code with robust error handling
        echo "## Code Metrics Report" > metrics.md
        echo "" >> metrics.md
        echo "### Lines of Code" >> metrics.md
        
        # Safer line counting approach
        domain_lines=$(find src/Domain -name "*.cs" 2>/dev/null | xargs wc -l 2>/dev/null | tail -1 | awk '{print $1}' || echo "0")
        app_lines=$(find src/Application -name "*.cs" 2>/dev/null | xargs wc -l 2>/dev/null | tail -1 | awk '{print $1}' || echo "0")
        infra_lines=$(find src/Infrastructure -name "*.cs" 2>/dev/null | xargs wc -l 2>/dev/null | tail -1 | awk '{print $1}' || echo "0")
        test_lines=$(find tests -name "*.cs" 2>/dev/null | xargs wc -l 2>/dev/null | tail -1 | awk '{print $1}' || echo "0")
        
        echo "- Domain: $domain_lines" >> metrics.md
        echo "- Application: $app_lines" >> metrics.md  
        echo "- Infrastructure: $infra_lines" >> metrics.md
        echo "- Tests: $test_lines" >> metrics.md
        echo "" >> metrics.md
        
        # Safer test counting
        echo "### Test Count" >> metrics.md
        echo "- Total Tests: $(find tests -name "*.cs" -exec grep -l "Test" {} \; 2>/dev/null | wc -l || echo "Unknown")" >> metrics.md
        
    - name: ğŸ” Check for outdated packages
      id: check-packages
      run: |
        echo "ğŸ” Checking for outdated packages..."
        
        outdated=$(dotnet list package --outdated) || true
        if echo "$outdated" | grep -q "has the following updates"; then
          echo "has_updates=true" >> $GITHUB_OUTPUT
          echo "$outdated" > outdated-packages.txt
        else
          echo "has_updates=false" >> $GITHUB_OUTPUT
        fi
        
    - name: ğŸ”§ Fix common issues
      run: |
        echo "ğŸ”§ Running common issue fixes..."
        
        # Normalize line endings
        find . -type f -name "*.cs" -exec dos2unix {} \; 2>/dev/null || true
        
        # Remove trailing whitespace
        find . -type f -name "*.cs" -exec sed -i 's/[[:space:]]*$//' {} \; || true
        
        # Ensure all files end with newline
        find . -type f -name "*.cs" -exec sh -c 'tail -c1 "$1" | read -r _ || echo >> "$1"' _ {} \; || true
        
    - name: ğŸ“ Create maintenance PR
      if: steps.check-packages.outputs.has_updates == 'true' || github.event_name == 'workflow_dispatch'
      run: |
        # Configure git
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Create branch
        branch_name="chore/weekly-maintenance-$(date +%Y%m%d)"
        git checkout -b $branch_name
        
        # Stage all changes
        git add -A
        
        # Check if there are changes to commit
        if [[ -n $(git status --porcelain) ]]; then
          # Commit changes
          git commit -m "chore: weekly maintenance and cleanup
          
          - ğŸ§¹ Cleaned build artifacts
          - ğŸ”§ Formatted code
          - ğŸ“Š Updated metrics
          - ğŸ” Checked for outdated packages
          
          [skip ci]"
          
          # Push branch
          git push -u origin $branch_name
          
          # Create PR
          gh pr create \
            --title "ğŸ§¹ Weekly Maintenance" \
            --body "## ğŸ¤– Automated Weekly Maintenance
            
            This PR contains automated maintenance tasks:
            
            ### âœ… Completed Tasks:
            - ğŸ§¹ Cleaned stale build artifacts
            - ğŸ”§ Formatted all code files
            - ğŸ“Š Generated code metrics
            - ğŸ” Checked for outdated packages
            
            ### ğŸ“Š Metrics:
            See metrics.md for current code statistics
            
            ### ğŸ”„ Auto-Merge:
            This PR will auto-merge if all checks pass.
            
            ---
            *Generated by Zero-Friction CI*" \
            --label "automated" \
            --label "maintenance"
        else
          echo "âœ… No maintenance needed - codebase is clean!"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  clean-old-branches:
    name: ğŸŒ¿ Clean Stale Branches
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Clean merged branches
      run: |
        echo "ğŸŒ¿ Cleaning merged branches..."
        
        # List merged branches (except main/develop)
        merged_branches=$(git branch -r --merged origin/main | grep -v -E "(main|develop|HEAD)" | sed 's/origin\///')
        
        if [ -n "$merged_branches" ]; then
          echo "Found merged branches to delete:"
          echo "$merged_branches"
          
          for branch in $merged_branches; do
            echo "Deleting $branch..."
            git push origin --delete $branch || echo "Could not delete $branch"
          done
        else
          echo "âœ… No merged branches to clean"
        fi
        
    - name: Report stale branches
      run: |
        echo "ğŸ“Š Checking for stale branches..."
        
        # Find branches not updated in 30 days
        stale_date=$(date -d '30 days ago' +%Y-%m-%d)
        
        gh api repos/${{ github.repository }}/branches --paginate | \
          jq -r '.[] | select(.name != "main" and .name != "develop") | 
          select(.commit.commit.author.date < "'$stale_date'") | .name' > stale-branches.txt
          
        if [ -s stale-branches.txt ]; then
          echo "âš ï¸ Found stale branches (>30 days old):"
          cat stale-branches.txt
          
          # Create issue for manual review
          gh issue create \
            --title "ğŸŒ¿ Stale branches need review" \
            --body "The following branches haven't been updated in 30+ days:
            
$(cat stale-branches.txt | sed 's/^/- /')
            
Please review and delete if no longer needed." \
            --label "maintenance"
        else
          echo "âœ… No stale branches found"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}